---
title: "Community and habitat analysis"
runtime: shiny
output: 
  html_document:
    toc: true
    toc_float: 
       collapsed: false
---

```{r setupcommhaban, include = FALSE}
# globals
library(knitr)
opts_chunk$set(echo = F, message = F, warning = F)

library(tidyverse)
library(sf)
library(mapview)
library(shiny)
library(scales)
library(leaflet)
library(ggord)
library(vegan)
library(ggdendro)
library(dendextend)
library(shinyWidgets)
library(ggrepel)

source('R/funcs.R')

data(habitat)
data(fishdat)
data(stream)

prj <- "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"

# prep species data for multivariate analysis, long format 
spdat <- fishdat %>% 
  dplyr::select(Year, Watershed, SiteID, matches('^Sp_')) %>% 
  gather('species', 'pa', -Year, -SiteID, -Watershed, -geometry) %>% 
  mutate(
    species = gsub('^Sp_', '', species)
  ) %>% 
  filter(!is.na(Year)) %>% 
  unique

# prep species data for multivariate analysis
# same as spdat, but no geometry
mltspdat <- spdat
st_geometry(mltspdat) <- NULL

# prep habitat data for multivariate analysis
# same as habitat, but no geometry
mlthbdat <- habitat
st_geometry(mlthbdat) <- NULL

# site, wshed lookup
siteshd <- fishdat
st_geometry(siteshd) <- NULL
siteshd <- siteshd %>% 
  dplyr::select(SiteID, Watershed) %>% 
  unique %>% 
  mutate_if(is.factor, as.character)

# ggplot base 
pbase <- theme_bw(base_family = 'serif') +
  theme(
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank(), 
    axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, size = 8), 
    axis.text.y = element_text(size = 8),
    legend.position = 'top',
    legend.direction = 'horizontal',
    # plot.margin = unit(c(4,4,0,0), "lines"),
    strip.background = element_blank(), 
    strip.text.y = element_text(angle = 0, hjust = 0, vjust = 0.5), 
    panel.background = element_rect(fill = 'black')
  ) 

# habitat variables to select, master obj
habvrs <- list(
  'Canopy cover (%)' = 'StnCan',
  'Deciduous canopy cover (%)' = 'StnDecid', 
  'Average depth (ft)' = 'StnDpthAvg',
  'Maximum depth (ft)' = 'StnDpthMax',
  'Embeddedness (%)' = 'StnEmbed',
  'Escape cover (ratio)' = 'StnEsCov',
  'Fines (%)' = 'StnFines',
  'Station length (ft)' = 'StnLgth',
  'Station width (ft)' = 'StnWdth'
  )

# map colors
cols <- mapviewGetOption("vector.palette")(4)

# map colors for wsheds
colgrp <- data.frame(
  Watershed = c('APT', 'PAJ', 'SLR', 'SOQ'), 
  cols = cols, 
  stringsAsFactors = F
)
```

This section can be used to evaluate community changes over time and how these changes may relate to measured habitat variables.  The setup is similar as the analysis on the [community](comman.Rmd) page with some important differences.    

1) The species presence/absence (community) data are clustered as before, with options to select clustering methods, dissimilarity measures, and number of groups.
1) The comparison of community and habitat data is done using constrained ordination analysis that jointly considers relationships among species in the community data and how those relationships compare to patterns in the habitat data.  
1) The results from th last step can be compared to the groupings in the first step to identify if:
     * The groupings are still relevant when considering relationships with habitat,
     * If relevant, which habitat variables are important for species groupings?
1) A necessary limitation of the analysis is that sites must match between the community and habitat data.  This places additional restrictions on the data.

Some questions to consider when evaluating the data are:

1) Do the results differ when evaluating the results between years?
1) Is there an effect of adding or removing habitat variables from the analysis?
1) Can the results be explained by community or habitat differences between the watersheds?
1) If not, are there other natural groupings in the data that can describe community differences?
1) How does the chosen method of analysis affect the results (i.e., how robust are the conclusions with changes in the methods)? Changes to the methods to consider include effects of rare species, chosen dissimilarity measure, chosen clustering algorithm, and how groups are defined from the clustering results.

```{r mltsetup}
# select a year
column(width = 12, 
       selectInput('yrmlt', 'Select a year for comparison (species and habitat data):', sort(unique(mlthbdat$Year)), selected = 2017)
       )
```

```{r ccaord}
# species and habitat data for ordination 
# returns two element list with names toordsp, toordhb
# sites (rows) are matched between the species and habitat data
toord <- reactive({
  
  # inputs
  yrmlt <- input$yrmlt
  remrr <- input$remrr
  habvr <- input$habvr
  habty <- input$habty

  # create species pa mat after filtering species at less than remrr sites
  toordsp <- mltspdat %>% 
    filter(Year == yrmlt) %>% 
    dplyr::select(SiteID, Watershed, species, pa) %>% 
    group_by(species) %>% 
    mutate(totsp = sum(pa)) %>% 
    filter(totsp > remrr) %>% 
    dplyr::select(-totsp) %>% 
    spread(species, pa) %>% 
    data.frame(stringsAsFactors = F)
  rownames(toordsp) <- NULL
  toordsp <- toordsp %>% 
    column_to_rownames('SiteID')

  # remove sites with nothing found after rare spp removed
  torm <- rowSums(toordsp[, !names(toordsp) %in% c('Watershed')])
  toordsp <- toordsp[torm > 0, ]
  
  # create habitat data as input for ord
  # data are centered and scaled
  toordhb <- mlthbdat %>% 
    filter(Year == yrmlt) %>% 
    filter(habvar %in% habvr) %>% 
    filter(HabType %in% habty) %>% 
    dplyr::select(SiteID, Watershed, habvar, habval) %>% 
    spread(habvar, habval) %>% 
    data.frame(stringsAsFactors = F) %>% 
    mutate_if(is.numeric, base::scale)
  rownames(toordhb) <- NULL
  toordhb <- toordhb %>% 
    column_to_rownames('SiteID')
  
  # find matching sites and subset
  stmt <- dplyr::intersect(rownames(toordhb), rownames(toordsp)) %>% sort
  toordsp <- toordsp[stmt, ]
  toordhb <- toordhb[stmt, ]

  # output
  out <- list(toordsp = toordsp, toordhb = toordhb)  
  return(out)
  
})

# wshed groups for ggord
wshdord <- reactive({

  toord()[['toordsp']] %>% pull(Watershed)
  
})

# dissimilarity matrix
dis <- reactive({
  
  # input
  distyp <- input$distyp

  toordsp <- toord()[['toordsp']] %>% 
    dplyr::select(-Watershed) 
  
  # metaMDS
  dis <- toordsp %>% 
    vegdist(method = distyp)
  
  return(dis)
  
})

# ordination
ccaord <- reactive({
  
  # input
  toordsp <- toord()[['toordsp']]
  toordhb <- toord()[['toordhb']]

  # remove watershed column
  toordsp <- toordsp %>% 
    dplyr::select(-Watershed) 
  toordhb <- toordhb %>% 
    dplyr::select(-Watershed)
  
  # remove Stn prefix from habitat names
  names(toordhb) <- gsub('^Stn', '', names(toordhb))

  # metaMDS
  ccaord <- cca(toordsp, toordhb)
  
  return(ccaord)
  
})
```

## Species clustering results {.tabset}

```{r clstin}
# remove species at less than x sites
column(width = 6, 
       selectInput('remrr', 'Remove species occurring at n sites or less:', selected = 1, choices = seq(0, 20))
       )

# select dissimilarity measure
column(width = 6, 
       selectInput('distyp', 'Select dissimilarity measure for clustering', 
                   selected = 'jaccard', choices = c('jaccard', 'bray', 'euclidean', 'raup'))
       )

# select cluster type
column(width = 6, 
       selectInput('clsttyp', 'Select cluster type:', selected = 'average', choices = c('ward.D', 'ward.D2', 'single', 'complete', 'average', 'mcquitty', 'median', 'centroid'))
)

# select cluster cuts
column(width = 6, 
       selectInput('clstcut', 'Select cluster groups:', selected = 2, choices = c(1:10))
)
```

<br>

### Dissimilarity matrix

```{r}
# select matrix order type
column(width = 6,
  selectInput('byclst', 'Order by?', selected = 'Clusters', choices = c('Watershed', 'Clusters'))
)

# show cluster method if matrix order type is cluster
column(width = 6, 
       renderText({if(input$byclst == 'Clusters') paste0('Cluster method: ', input$clsttyp)})
)
```

```{r displt, out.width = "100%"}
renderPlot({
  
  # inputs
  byclst <- input$byclst
  dis <- dis()
  clst <- clst()
  clstgrps <- clstgrps()

  # prep distance data to plot
  # long format of dist matrix, joind with wshed
  toplo <- dis %>% 
    as.matrix %>% 
    as.data.frame %>%
    rownames_to_column('SiteID') %>% 
    gather('SiteID2', 'dist', -SiteID) %>% 
    left_join(siteshd, by = 'SiteID') %>% 
    arrange(Watershed, dist) %>% 
    mutate(
      Watershed = factor(Watershed, levels = unique(Watershed)), 
      dist = ifelse(SiteID == SiteID2, NA, dist)
      )
  
  # get site order levels based on clustering
  if(byclst == 'Clusters'){
    
    sitfc <- clst$labels[clst$order]
    toplo <- toplo %>% 
      mutate(
        SiteID = factor(SiteID, levels = sitfc), 
        SiteID2 = factor(SiteID2, levels = sitfc)
      )
    
  } 
  
  # plot
  p <- ggplot(toplo) + 
    geom_tile(aes(x = SiteID, y = SiteID2, fill = dist), colour = 'black') +
    scale_x_discrete('', expand = c(0, 0)) + 
    scale_y_discrete('', expand = c(0, 0)) +
    scale_fill_gradient2('Dissimilarity between sites\nby species p/a', low = 'white', mid = 'lightblue', high = 'tomato1', midpoint = 0.5) +
    guides(fill = guide_colourbar(barheight = 0.5, barwidth = 10, label.theme = element_text(size = 10, angle = 0))) + 
    pbase
  
  # add vline/hline
  if(byclst == 'Watershed'){
      
    # index values of watershed divisions in plot
    brks <- toplo %>% 
      spread(SiteID2, dist) %>% 
      pull(Watershed) %>% 
      duplicated %>% 
      `!` %>% 
      which %>% 
      `-` (0.5) %>% 
      .[-1]
  
  } else {
    
    # index values of watershed divisions in plot
    brks <- clstgrps %>% 
      .[clst$order] %>% 
      duplicated %>% 
      `!` %>% 
      which %>% 
      `-` (0.5) %>% 
      .[-1]
    
  }
    
  # add watershed or cluster breaks to the plot
  p <- p + 
    geom_vline(xintercept = brks, size = 1.5) +
    geom_hline(yintercept = brks, size = 1.5)
  
  return(p)
  
}, width = 650, height = 700)
```

### Dendrograms 

```{r clstpl}
# cluster analysis
clst <- reactive({
  
  # inputs
  clsttyp <- input$clsttyp
  
  out <- dis() %>% 
    hclust(method = clsttyp)
  
  return(out)
  
})

# get cluster groups
clstgrps <- reactive({
  
  # input
  clst <- clst()
  clstcut <- input$clstcut

  # get cut groups
  grps <- cutree(clst, k = clstcut)
  
  return(grps)
  
})
```

```{r dend}
# cluster dendrogram
renderPlot({
  
  # input
  clst <- clst()
  clstcut <- input$clstcut
  
  # cols <- mapviewGetOption("vector.palette")(clstgrps)
  
  p1 <- clst %>% 
    as.dendrogram %>% 
    set("branches_k_color", k = clstcut) %>%
    set("labels_colors", k = clstcut) %>%
    set("labels_cex", 0.8) 
  
  plot(p1)
  
})
```

### Cluster map

```{r mapclstprp}
# subset year and species,  map
mapclst <- reactive({
  
  # inputs
  clstgrps <- clstgrps()
  
  # clstgrps dataframe
  clstgrps <- clstgrps %>% 
    data.frame(clstgrps = .) %>% 
    rownames_to_column('SiteID')
  
  toplo <- spdat %>%
    dplyr::select(SiteID) %>% 
    unique %>% 
    mutate(SiteID = as.character(SiteID)) %>% 
    inner_join(clstgrps, by = 'SiteID')

  out <- mapview(stream, label = stream$STREAM_NM, homebutton = F) +
    mapview(toplo, zcol = 'clstgrps', legend = F, homebutton = F)

  return(out)
  
})
```

```{r mapclst}
renderLeaflet({mapclst()@map})
```

## Constrained ordination {.tabset}

```{r}
# habitat type to evaluate
column(width = 6, 
       selectInput("habty", label = 'Choose habitat type to evaluate:', choices = c('run', 'riffle', 'pool'))
)

# habitat variables to consider
column(width = 6, 
  pickerInput("habvr", label = 'Choose a habitat variables to consider:', choices = habvrs, selected = habvrs,
                                                multiple = TRUE
                                    )
  )
```

```{r}
# # some chatty stuff about the ordination
# renderText({
#   
#   # input
#   toprnt <- ccaord()
#   
#   strs <- toprnt %>% .$stress %>% round(2)
#   cnvr <- toprnt %>% .$converged
#   
#   if(cnvr)
#     txt <- paste0('Ordination converged, final stess value: ', strs)
#   else 
#     txt <- paste0('Ordination did not converge, final stess value: ', strs)
#   
#   return(txt)
# 
# })
```

### Triplot

```{r selax}
column(6, 
  renderUI({
    
    # inputs
    ccaord <- ccaord()
    
    # possible axes to select
    axs <- seq_along(colnames(ccaord$CCA$wa))
  
    selectInput('axsx', 'Select CCA axis for x-axis:', choices = axs, selected = 1)
    
  })
)

column(6, 
  renderUI({
    
    # inputs
    ccaord <- ccaord()
    
    # possible axes to select
    axs <- seq_along(colnames(ccaord$CCA$wa))
  
    selectInput('axsy', 'Select CCA axis for y-axis:', choices = axs, selected = 2)
    
  })
)
```

```{r ordplt, out.width = "100%"}
renderPlot({
  
  # input
  ccaord <- ccaord()
  clstcut <- as.numeric(input$clstcut)
  clstgrps <- clstgrps()
  axsx <- input$axsx
  axsy <- input$axsy

  # use watersheds as groups if clstcut is one, otherwise cluster groups
  if(clstcut == 1){

    grpin <- as.character(wshdord())

    # subset colors by actual wsheds in ord
    colsub <- colgrp %>%
      filter(Watershed %in% unique(wshdord())) %>%
      pull(cols)

  } else {

    grpin <- as.character(clstgrps)
    colsub <-  mapviewGetOption("vector.palette")(clstcut)

  }

  pord <- ggord(ccaord, grp_in = grpin, axes = c(axsx, axsy), vec_ext = 4, col = colsub, ptslab = T, parse = T,
        alpha = 1, alpha_el = 0.2, size = 4, txt = 5, addsize = 4, arrow = 0.5, repel = F, coord_fix = F) +
    theme_bw(base_family = 'serif', base_size = 16) +
    theme(legend.position = 'top')

  return(pord)

}, width = 700, height = 700)
```

### Dominant species by group

```{r}
renderPlot({
  
  # inputs
  clstgrps <- clstgrps()
  toordsp <- toord()[['toordsp']]

  # toplo
  toplo <- toordsp %>% 
    dplyr::select(-Watershed) %>% 
    mutate(clstgrps = clstgrps) %>% 
    gather('spp', 'pa', -clstgrps) %>% 
    group_by(clstgrps, spp) %>% 
    summarise(
      cnts = sum(pa)
      ) %>% 
    mutate(
      pers = 100 * cnts/sum(cnts)
    ) %>% 
    ungroup %>% 
    filter(pers > 0) %>% 
    unite('clstsp', clstgrps, spp, remove = F) %>% 
    arrange(clstgrps, pers) %>% 
    group_by(clstgrps) %>% 
    mutate(
      clstsp = factor(clstsp, levels = clstsp),
      perscum = cumsum(pers)
    )
      
  # plot
  p <- ggplot(toplo, aes(x = factor(clstgrps), fill = pers, group = factor(clstgrps))) +
    geom_bar(stat = 'identity', aes(y = pers), width = 0.25, colour = 'black') +
    geom_text_repel(aes(label = spp, y = perscum), angle = 0, nudge_x = 0.25, hjust = 0, direction = 'y') +
    scale_x_discrete('Group') + 
    scale_y_continuous('Cumulative occupied sites (%)') +
    scale_fill_distiller('%', palette = 'Spectral') +
    coord_flip() +
    theme_minimal(base_size = 18, base_family = 'serif') +
    theme(
      panel.grid.minor = element_blank(), 
      panel.grid.major = element_blank()
    )

  return(p)
  
}, height = 500, width = 900)
```

### Top habitat variables by group
