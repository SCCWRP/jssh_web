---
title: "Community analysis"
runtime: shiny
output: 
  html_document:
    toc: true
    toc_float: 
       collapsed: false
---

```{r setupcomman, include = FALSE}
# globals
library(knitr)
opts_chunk$set(echo = F, message = F, warning = F)

library(tidyverse)
library(sf)
library(mapview)
library(shiny)
library(scales)
library(leaflet)
library(ggord)
library(vegan)
library(ggdendro)
library(dendextend)

# data, funcs, globals
prj <- "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"

source('R/funcs.R')

data(fishdat)
data(stream)

# map colors
cols <- mapviewGetOption("vector.palette")(4)

colgrp <- data.frame(
  Watershed = c('APT', 'PAJ', 'SLR', 'SOQ'), 
  cols = cols, 
  stringsAsFactors = F
)

# ggplot base 
pbase <- theme_bw(base_family = 'serif') +
  theme(
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank(), 
    axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, size = 8), 
    axis.text.y = element_text(size = 8),
    legend.position = 'top',
    legend.direction = 'horizontal',
    # plot.margin = unit(c(4,4,0,0), "lines"),
    strip.background = element_blank(), 
    strip.text.y = element_text(angle = 0, hjust = 0, vjust = 0.5), 
    panel.background = element_rect(fill = 'black')
  ) 

# prep species data, long format 
spdat <- fishdat %>% 
  select(Year, Watershed, SiteID, matches('^Sp_')) %>% 
  gather('species', 'pa', -Year, -SiteID, -Watershed, -geometry) %>% 
  mutate(
    species = gsub('^Sp_', '', species)
  ) %>% 
  filter(!is.na(Year)) %>% 
  unique

# site, wshed lookup
siteshd <- fishdat
st_geometry(siteshd) <- NULL
siteshd <- siteshd %>% 
  select(SiteID, Watershed) %>% 
  unique %>% 
  mutate_if(is.factor, as.character)
```

<br>

These analyses can be used to evaluate changes in community composition over time using the presence/absence data for all species.  The first two sections show general changes by species and the third section is a formal multivariate analysis showing ordination and clustering results of the communities for a selected year.  Changes over time can be assessed by comparing the results between years. 

## Overview maps

This map shows species presence/absence in the four watersheds.  Sites that were sampled for the selected year are shown on the map with small red points indicating a selected species was not found and large green points indicating a species was found at a site.

__If data were collected at a site, was the selected species observed (green: yes, red: no)?__
```{r sppinput}
# select a species
column(width = 6,
 selectInput('sp', 'Select a species:', sort(unique(spdat$species)), selected = 'Sthd')
)

# select a year
column(width = 6, 
       selectInput('yr', 'Select a year:', selected = 2017, choices = sort(unique(spdat$Year)))
       )
```

```{r prepmapsp}
# subset year and species,  map
mapspyr <- reactive({
  
  yr <- input$yr
  sp <- input$sp
  
  toplo <- spdat %>% 
    filter(Year == yr & species == sp) %>% 
    mutate(
      cexv = ifelse(pa == 1, 7, 3), 
      pa = factor(pa, levels = c('1', '0'), labels = c('present', 'absent')), 
      cols = ifelse(pa == 'present', 'lightgreen', 'tomato1')
      )
  
  # colors must be passed as vector
  cols <- toplo$cols
  
  out <- mapview(stream, label = stream$STREAM_NM, homebutton = F) +
    mapview(toplo, zcol = 'pa', cex = toplo$cexv, label = paste0(toplo$SiteID, ': ', toplo$pa), legend = F, homebutton = F, col.region = cols)
   
  return(out)
  
})
```

```{r mapsp}
renderLeaflet({mapspyr()@map})
```
<br>

## Percent occupied sites over time

These plots show the percent of sampled sites over time that are occupied with a selected species, grouped by watershed.  The total number of sites that were sampled in each watershed, year combination is shown inside the point.

```{r tmsel}
# select a species
column(width = 6,
 selectInput('sptm', 'Select a species:', sort(unique(spdat$species)), selected = 'Sthd')
)

# year slider
column(width = 6, 
  sliderInput("yrs", label = 'Select year ranges to plot:',  
        min = 1994, max = 2017, 
        value = c(1994, 2017),
        sep = '', ticks = FALSE
      )
)
```

```{r spyragg}
# percent of sites where species was observed, by watershed, year
spyragg <- reactive({
  
  # inputs
  sp <- input$sptm
  yrs <- input$yrs
  
  # tabulate percent sites occupied
  out <- spdat
  st_geometry(out) <- NULL
  out <- out %>% 
    filter(species %in% sp) %>% 
    filter(Year >= yrs[1] & Year <= yrs[2]) %>% 
    group_by(Watershed, Year) %>% 
    summarize(
      nprs = sum(pa),
      nsites = n()
    ) %>% 
    mutate(
      prcsit = 100 * nprs / nsites
    )
  
  return(out)
  
})
```

```{r prsplo, out.width = "100%"}
renderPlot({
  
  # inputs
  toplo <- spyragg()
  sptm <- input$sptm
  
  p <- ggplot(toplo, aes(y = prcsit, x = Year)) + 
    geom_line() + 
    geom_point(pch = 21, aes(fill = prcsit), size = 8) +
    facet_wrap(~Watershed, ncol = 2) + 
    theme_bw(base_family = 'serif', base_size = 18) +
    theme(
      strip.background = element_blank(),
      axis.title.x = element_blank(), 
      legend.position = 'none'
    ) + 
    scale_y_continuous(paste0('% sites with ', sptm), limits = c(0, 100)) + 
    geom_text(aes(label = nsites), vjust = 0.5, size = 4, color = 'black') + 
    scale_fill_gradientn(colors = c('tomato1', 'lightgreen'), limits = c(0, 100))

  return(p)
                       
},width = 900, height = 600)

```
<br>

## Multivariate community analysis

This section can be used to evaluate community changes over time by showing natural groupings between sites using species presence/absence data.  Some questions to consider when evaluating the data are:

1) Do the results differ when evaluating the results between years?
2) Can the results be explained by community differences between the watersheds?
3) If not, are there other natural groupings in the data that can describe community differences?
4) How does the chosen method of analysis affect the results (i.e., how robust are the conclusions with changes in the methods)?

There are several options to consider when exploring the data.  Results from multivariate analyses can change depending on presence of rare species (those that occur at fewer than n sites), the measure used to evaluate dissimilarity between sites, the clustering algorithm, and how groups are defined from the clustering results.  All of these options can be changed with the sliders.  

```{r mltsetup}
mltdat <- spdat
st_geometry(mltdat) <- NULL

# select a year
column(width = 6, 
       selectInput('yrmlt1', 'Select a year for first comparison:', sort(unique(mltdat$Year)), selected = 2017)
       )

# remove species at less than x sites
column(width = 6, 
       selectInput('remrr', 'Remove species occurring at n sites or less:', selected = 1, choices = seq(0, 20))
       )

# select dissimilarity measure
column(width = 6, 
       selectInput('distyp', 'Select dissimilarity measure for ordination/clustering', 
                   selected = 'jaccard', choices = c('jaccard', 'bray', 'euclidean', 'raup'))
       )

# select cluster type
column(width = 6, 
       selectInput('clsttyp', 'Select cluster type:', selected = 'average', choices = c('ward.D', 'ward.D2', 'single', 'complete', 'average', 'mcquitty', 'median', 'centroid'))
)

# select cluster cuts
column(width = 12, 
       selectInput('clstcut', 'Select cluster groups:', selected = 2, choices = c(1:10))
)

```

<br>

```{r ord1}
# data for ordination first year
mltdatyr1 <- reactive({
  
  # inputs
  yrmlt1 <- input$yrmlt1
  remrr <- input$remrr

  # create species pa mat after filtering species at less than remrr sites
  toord <- mltdat %>% 
    filter(Year == yrmlt1) %>% 
    dplyr::select(SiteID, Watershed, species, pa) %>% 
    group_by(species) %>% 
    mutate(totsp = sum(pa)) %>% 
    filter(totsp > remrr) %>% 
    select(-totsp) %>% 
    spread(species, pa) %>% 
    data.frame(stringsAsFactors = F)
  rownames(toord) <- NULL
  toord <- toord %>% 
    column_to_rownames('SiteID')

  # remove sites with nothing found after rare spp removed
  torm <- rowSums(toord[, !names(toord) %in% c('Watershed')])
  toord <- toord[torm > 0, ]
  
  return(toord)
  
})

# wshed groups for ggord
wshdord1 <- reactive({
  
  mltdatyr1() %>% pull(Watershed)
  
})

# dismat year 1
dis1 <- reactive({
  
  # input
  distyp <- input$distyp
  
  toord <- mltdatyr1() %>% 
    select(-Watershed) 
  
  # metaMDS
  dis <- toord %>% 
    vegdist(method = distyp)
  
  return(dis)
  
})

# ordination year 1
ord1 <- reactive({
  
  # input
  distyp <- input$distyp
  
  toord <- mltdatyr1() %>% 
    select(-Watershed) 
  
  # metaMDS
  ord <- toord %>% 
    metaMDS(distance = distyp)
  
  return(ord)
  
})
```

## {.tabset}

### Ordination biplot

```{r}
# some chatty stuff about the ordination
renderText({
  
  # input
  toprnt <- ord1()
  
  strs <- toprnt %>% .$stress %>% round(2)
  cnvr <- toprnt %>% .$converged
  
  if(cnvr)
    txt <- paste0('Ordination converged, final stess value: ', strs)
  else 
    txt <- paste0('Ordination did not converge, final stess value: ', strs)
  
  return(txt)

})
```

```{r ord1plt, out.width = "100%"}
renderPlot({
  
  # input
  clstcut <- as.numeric(input$clstcut)
  clstgrps <- clstgrps()
  
  # use watersheds as groups if clstcut is one, otherwise cluster groups
  if(clstcut == 1){
    
    grpin <- as.character(wshdord1())
    
    # subset colors by actual wsheds in ord
    colsub <- colgrp %>% 
      filter(Watershed %in% unique(wshdord1())) %>% 
      pull(cols)
    
  } else {
    
    grpin <- as.character(clstgrps)
    colsub <-  mapviewGetOption("vector.palette")(clstcut)
    
  }

  pord1 <- ggord(ord1(), grp_in = grpin, vec_ext = 1, col = colsub, 
        alpha = 1, alpha_el = 0.2, size = 4, txt = 5, arrow = 0.5, repel = F, coord_fix = F) + 
    theme_bw(base_family = 'serif', base_size = 16) +
    theme(legend.position = 'top')
  
  return(pord1)
  
}, width = 550, height = 600)
```

### Dissimilarity matrix

```{r}
# select matrix order type
column(width = 6,
  selectInput('byclst', 'Order by?', selected = 'Clusters', choices = c('Watershed', 'Clusters'))
)

# show cluster method if matrix order type is cluster
column(width = 6, 
       renderText({if(input$byclst == 'Clusters') paste0('Cluster method: ', input$clsttyp)})
)
```

```{r dis1plt, out.width = "100%"}
renderPlot({
  
  # inputs
  byclst <- input$byclst
  dis1 <- dis1()
  clst <- clst()
  clstgrps <- clstgrps()

  # prep distance data to plot
  # long format of dist matrix, joind with wshed
  toplo <- dis1 %>% 
    as.matrix %>% 
    as.data.frame %>%
    rownames_to_column('SiteID') %>% 
    gather('SiteID2', 'dist', -SiteID) %>% 
    left_join(siteshd, by = 'SiteID') %>% 
    arrange(Watershed, dist) %>% 
    mutate(
      Watershed = factor(Watershed, levels = unique(Watershed)), 
      dist = ifelse(SiteID == SiteID2, NA, dist)
      )
  
  # get site order levels based on clustering
  if(byclst == 'Clusters'){
    
    sitfc <- clst$labels[clst$order]
    toplo <- toplo %>% 
      mutate(
        SiteID = factor(SiteID, levels = sitfc), 
        SiteID2 = factor(SiteID2, levels = sitfc)
      )
    
  } 
  
  # plot
  p <- ggplot(toplo) + 
    geom_tile(aes(x = SiteID, y = SiteID2, fill = dist), colour = 'black') +
    scale_x_discrete('', expand = c(0, 0)) + 
    scale_y_discrete('', expand = c(0, 0)) +
    scale_fill_gradient2('Dissimilarity between sites\nby species p/a', low = 'white', mid = 'lightblue', high = 'tomato1', midpoint = 0.5) +
    guides(fill = guide_colourbar(barheight = 0.5, barwidth = 10, label.theme = element_text(size = 10, angle = 0))) + 
    pbase
  
  # add vline/hline
  if(byclst == 'Watershed'){
      
    # index values of watershed divisions in plot
    brks <- toplo %>% 
      spread(SiteID2, dist) %>% 
      pull(Watershed) %>% 
      duplicated %>% 
      `!` %>% 
      which %>% 
      `-` (0.5) %>% 
      .[-1]
  
  } else {
    
    # index values of watershed divisions in plot
    brks <- clstgrps %>% 
      .[clst$order] %>% 
      duplicated %>% 
      `!` %>% 
      which %>% 
      `-` (0.5) %>% 
      .[-1]
    
  }
    
  # add watershed or cluster breaks to the plot
  p <- p + 
    geom_vline(xintercept = brks, size = 1.5) +
    geom_hline(yintercept = brks, size = 1.5)
  
  return(p)
  
}, width = 650, height = 700)
```

### Cluster analysis

```{r clstpl}
# cluster analysis
clst <- reactive({
  
  # inputs
  clsttyp <- input$clsttyp
  
  out <- dis1() %>% 
    hclust(method = clsttyp)
  
  return(out)
  
})

# get cluster groups
clstgrps <- reactive({
  
  # input
  clst <- clst()
  clstcut <- input$clstcut

  # get cut groups
  grps <- cutree(clst, k = clstcut)
  
  return(grps)
  
})
```

```{r dend}
# cluster dendrogram
renderPlot({
  
  # input
  clst <- clst()
  clstcut <- input$clstcut
  
  # cols <- mapviewGetOption("vector.palette")(clstgrps)
  
  p1 <- clst %>% 
    as.dendrogram %>% 
    set("branches_k_color", k = clstcut) %>%
    set("labels_colors", k = clstcut) %>%
    set("labels_cex", 0.8) 
  
  plot(p1)
  
})
```

### Cluster map

```{r mapclstprp}
# subset year and species,  map
mapclst <- reactive({
  
  # inputs
  clstgrps <- clstgrps()
  
  # clstgrps dataframe
  clstgrps <- clstgrps %>% 
    data.frame(clstgrps = .) %>% 
    rownames_to_column('SiteID')
  
  toplo <- spdat %>%
    select(SiteID) %>% 
    unique %>% 
    mutate(SiteID = as.character(SiteID)) %>% 
    inner_join(clstgrps, by = 'SiteID')

  out <- mapview(stream, label = stream$STREAM_NM, homebutton = F) +
    mapview(toplo, zcol = 'clstgrps', legend = F, homebutton = F)

  return(out)
  
})
```

```{r mapclst}
renderLeaflet({mapclst()@map})
```